\chapter{Design \& Implementation}
\label{ch:design}

This chapter will present the challenges encountered creating the system, what the most critical components are and the choices we made to overcome said issues. We will first present the components that will build up the system, what their responsibility are and the choices that lead us to such a division. Then tackle each component one by one, focusing separately on each challenge. Afterwards we will combine all the choices and present the final architecture of the system developed.

\section{Components}
\label{sec:components}

From previous work, the main challenges we expect to face are mainly related to the maintainability of the software and its stability. A further complexity factor to the design is the importance of allowing the system to leverage the full power of \acrshort{vtk}. As such, we opt for an architecture with components that each have a precise separate concern \cite{Hursch95separationof}. This choice stems from maintainability concerns arising from previous work's code, where components were highly coupled with both the visualization library and the engine \cite{dreuning_visual_2016, duking_potential_2018, kruis_creating_2017, wheeler_virtual_2018}.

The most basic design of our architecture requires two main endpoints, that are \acrshort{vtk} and Unity, a native layer of interfacing between the two and a managed Unity plugin for interfacing native code with the engine. The bare bones implementation was developed by Wheeler et al. \cite{wheeler_virtual_2018}, on which our solution is based. This gives us an infrastructural basement on which our further components then work.

To achieve our goal of full integration of VTK, we cannot rely on hardcoded functions, which would impair the stability of the system, as well as its maintainability. As such, our solution comprises an introspecting component that enables the gathering of metadata on \acrshort{vtk} and thus limits the coupling of the solution to a particular version of \acrshort{vtk}.

On the other side, the expression of such metadata also needs to be lowly coupled with the particular implementation of either \acrshort{vtk} or Unity, and as such a component is introduced to enable the generation on-the-fly of UI that fits the I/O operations required to support the development environment. The design of the UI parts themselves is out of the scope of this thesis, we will only discuss its library implementation, which enables the creation of the UIs.

Finally, this generality may come at the price of performance, as introspection may be slow, interfacing may not be complete through it, as we will discuss in Section~\ref{sec:design-introspection}, and the UI generation may be slow when working with big and complex pipeline filters. As such, to enable users to enhance their experiences, both with tailored more user-friendly UIs as well as focused and efficient adapters that create a direct link between the infrastructure and \acrshort{vtk} features.

The final architecture will be composed of a total of six components, as shown in Figure~\ref{fig:high-level-architecture}:

\begin{itemize}
    \item An \textbf{Infrastructure Layer} which acts as bridge between \acrshort{vtk} and Unity;
    \item A \textbf{\acrshort{vtk} Interfacing Layer}, comprised of an \textbf{Adapter Interface}, which uses custom made code by the user to interface with \acrshort{vtk}, and an \textbf{Introspection Interface}, which uses introspection over \acrshort{vtk} to access its features;
    \item A \textbf{Unity Managed plugin} which allows Unity to access the functionality exposed by the \textit{Infrastructure Layer};
    \item A \textbf{Unity UI Library}, comprised of a \textbf{UI Toolbox}, which is made of custom UIs created to tailor specific usages, and a \textbf{UI Composer}, which uses a minimal set of UI components to generate UIs on-the-fly.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{pictures/Architecture-high-level-transparent.png}
    \caption{Components and their interconnections.}
    \label{fig:high-level-architecture}
\end{figure}

\section{Infrastructure}
\label{sec:design-infrastructure}

The infrastructure layer is the component responsible for allowing interaction between all other parts of the system. Its main job is to give a common entry-point to the \acrshort{vtk} interfaces and decide which to call. As this is the critical point of the system where communication flows, this is the component that mostly affects parallelization and distribution capabilities. As such, the calls should be as little blocking as possible.

Wheeler et al.'s VtkToUnity \cite{wheeler_virtual_2018} already partly implements this infrastructure layer. Their solution though already implements part of the \acrshort{vtk} interface as well. Furthermore, their calls are highly blocking, as once the C++ native code executes, the Plugin calls each \verb|lock()| on the API and thus parallel calls are impossible. On the other hand, the plugin achieves decent performances that fall within the Unity guidelines for \acrshort{vr} \cite{noauthor_vr_nodate-1}, while allowing for good maintainability and extension possibilities, being native C++ code.

As such, we base the infrastructure layer on a refactoring of the VtkToUnity plugin which aims at the following results:

\begin{enumerate}
    \item Decoupling of the communication and dispatching from the interfacing responsibilities;
    \item Refactoring the interfacing code in adapters that will constitute the foundation of the adapter-based interfacing;
    \item Move as much business logic of the infrastructure in non-blocking calls, preferably with no blocking at the infrastructure layer;
    \item Move blocking logic at interface level.
\end{enumerate}

%As we expect the interfacing to be slower, especially with the introspection component, the infrastructure layer will also have a cache system to store and retrieve the latest hits and directly call the precise function rather than going through with the introspecting dispatch system.

We use the same approach as in the VtkToUnity plugin to create the C++ native plugin and its interfacing with Unity. Our implementation is then reduced to the minimal API necessary to use the \acrshort{vtk} functionality expressed by the interface mechanisms described in Section~\ref{sec:design-interfaces}. The interface is comprised of the following methods:

\begin{itemize}[leftmargin=1.5truecm]
    \setlength{\itemindent}{-1truecm}
    \item[] \verb|AddVtkObject(objectName, rgbaColour, wireframe, objectId)| takes as input a string representation of the \acrshort{vtk} object to instantiate, the rendering colour and a flag to show the wireframe, and returns the objectId of the shape, which is its index in the object registry that the infrastructure layer keeps;
    \item[] \verb|GetVtkObjectProperty(objectId, propertyName, returnValue)| takes as input the object's index in the registry and the name of the property, accesses the \acrshort{vtk} interface as described in Section~\ref{sec:design-interfaces}, and returns the string representation of the value;
    \item[] \verb|SetVtkObjectProperty(objectId, propertyName, newValue)| takes as input the object's index in the registry, the name of the property to change and the new value and accesses the \acrshort{vtk} interface to set the object's attribute to the new value;
    \item[] \verb|GetVtkObjectDescriptor(objectId)| takes as input the object's index in the registry, and returns a string representation of the attributes of the object; this is used then in the UI composer to generate the UI for manipulating the objects;
    \item[] \verb|RemoveVtkObject(objectId)| takes as input the object's index in the registry, and deletes it.
\end{itemize}

\section{VTK Interfaces}
\label{sec:design-interfaces}

The core feature of our system is its ability to access \acrshort{vtk} and expose it fully to the \acrshort{vr} development environment. To achieve this, while keeping the system easily maintainable and performing, we use a two way access system. The first access route uses a lookup to check whether custom adapters exist that can satisfy the request from the caller, while the second uses introspection capabilities on the library to find the appropriate method, function or class that can satisfy the request.

We will discuss both access tiers and how each of them is designed. Both these subsystems are intended to be separate services that the main architecture can either directly access when running in a stand-alone version on the users PC, or can be distributed on a network and be accessed through distribution engines such as DtCraft \cite{huang2017dtcraft} or Boost::MPI \cite{schaling2011boost}.

\subsection{Adapters}
\label{sec:design-adapters}

The first access tier for \acrshort{vtk} is a set of custom adapters that users can define, expand and modify and get built with the solution. These adapters have the objective of allowing the user to customize their system and tailor it to their needs. The user can define different ways in which the native plugin interacts with \acrshort{vtk}. Particular use cases for adapters are:

%TODO: implementation of other two use cases
\begin{itemize}
    \item The creation of custom loggers for diagnostics and flow analysis;
    \item Implementation of \textit{templates} at native level that enable faster instantiation and define their own parameters and routines;
    \item Implementation of custom algorithms that compound \acrshort{vtk} features.
\end{itemize}

The adapters are Singleton instances that define first and foremost a unique string identifying which component they are adapting. Such ID represents the name of the object the code adapts. For instance, an adapter for the \acrshort{vtk} source class \verb|vtkConeSource| will be identified by the class' name. Furthermore, each adapter has to implement access methods for getting descriptions of what attributes the class has, getting the values of each of those attributes and setting such values as well. 

Optionally, the adapter can implement rendering information in case the adapter is not for a specific \acrshort{vtk} class but for a template or custom algorithm, in which case information is needed on how to render and update the objects generated by the adapter.

The main driver behind adapters is to make the solution maintainable as well as generic. We do not foresee all potential uses of the adapters, as it is not our objective. Their implementation is kept to the bare minimum and some use cases are presented which are, to us, the most obvious. We set out to not limit the potential for these component, and require the implementation of what is needed to make it work.

In order to implement the defined adapters, we first define a basic adapter class which is used for only use case number 1, i.e. the adapting of \acrshort{vtk} defined objects. This class does not define rendering and update information, as these are already defined by \acrshort{vtk}. We implement \verb|VtkAdapter| as shown in listing~\ref{lst:vtkadapter}

\begin{figure}
    \centering
    \begin{cpp}[label=lst:vtkadapter,caption={vtkAdapter class}]
class VtkAdapter
{
public:
	template <typename T> using getter = std::stringstream(T::*)(vtkSmartPointer<vtkActor>);
	template <typename T> using setter = void (T::*)(vtkSmartPointer<vtkActor>, LPCSTR);

	virtual ~VtkAdapter() { }

	inline LPCSTR GetAdaptingObject() {
		return m_vtkObjectName;
	}

	virtual void SetAttribute(vtkSmartPointer<vtkActor> actor, LPCSTR propertyName, LPCSTR newValue) = 0;
	virtual void GetAttribute(vtkSmartPointer<vtkActor> actor, LPCSTR propertyName, char* retValue) = 0;
	virtual void GetDescriptor(char* retValue) const = 0;

protected:
	LPCSTR m_vtkObjectName;

	VtkAdapter(LPCSTR vtkObjectName) { 
		m_vtkObjectName = vtkObjectName;
	};
};
    \end{cpp}
\end{figure}

The class has a unique identifier in the form of a \verb|LPCSTR| (Long Pointer to Const STRing) which is to be set when instantiating the adapter. The class also carries with it a descriptor of the \acrshort{vtk} class that specifies what attributes the class has and what is their type. This descriptor is used by the Unity Managed plugin as we will discuss in Section~\ref{sec:design-uicomposer}.

Alongside these functions, there are two templates that define the types of \verb|getter| and \verb|setter| methods used by adapters. These functions will take as input a pointer to the actor that renders the \acrshort{vtk} object and the first will return a string representation of the value of the attribute while the second will take a further argument that is the new value to which attribute is to be set.

The generic calls for getting and setting attributes are respectively \verb|GetAttribute| and \verb|SetAttribute|. These functions act as dispatchers for the particular operations, that can either be directly implemented into the function but, as good practice, we will later show an example of how we recommend these adapters should be implemented.

The actual attribute to change is encoded in a \verb|LPCSTR| that contains the name of the attribute exactly as written in the C++ code. A difference from the \verb|GetAttribute| generic call and the particular \verb|getter| template is that the return value is not returned but a specific parameter acts as return buffer, as this value is not to be used inside the C++ native code but to be sent through to the C\# interface in Unity.

Alongside the adapters, the \verb|VtkAdapterUtility| provides the access point for the register of the adapters. This allows to couple adapters to a single point of entry and masks the adapters to the infrastructure layer, making it easy to execute on a separate service. The implementation of this class is generated by a Python script at build time, available in Appendix~\ref{apx:generate-register}. The interface of the utility is shown in Listing~\ref{lst:vtkadapterutility}.

\begin{figure}
    \centering
    \begin{cpp}[label=lst:vtkadapterutility,caption={VtkAdapterUtility interface}]
class VtkAdapterUtility
{
public:
	static VtkAdapter* GetAdapter(LPCSTR vtkAdaptedObject);

private:
	static const std::unordered_map<LPCSTR, VtkAdapter*> s_adapters;
};
    \end{cpp}
\end{figure}

As visible, the adapter only exposes the function \verb|GetAdapter| that returns the implementation of the adapter for the unique ID requested if such object exists, \verb|NULL| otherwise. The adapters are stored in an unordered map, as it has faster access times than the ordered counterparts \cite{stdunord16, stdmapcp55} on the average case. This depends on the hashing function, but as we use default types for keys and we do not replicate them, the average case is almost certainly guaranteed. The map is populated on instantiation and the entries are generated as Singletons, as shown in Listing~\ref{lst:adaptersmap}.

\begin{figure}
    \centering
    \begin{cpp}[label=lst:adaptersmap,caption={Example of adapters register instantiation.}]
const std::unordered_map<LPCSTR, VtkAdapter*> VtkAdapterUtility::s_adapters =
{
	{ Singleton<VtkConeSourceAdapter>::Instance()->GetAdaptingObject(), Singleton<VtkConeSourceAdapter>::Instance() },
	// More adapters...
};
    \end{cpp}
\end{figure}

\subsection{Introspection}
\label{sec:design-introspection}

As one of the objectives is to make the software less dependant on the \acrshort{vtk} version, a component with introspection capabilities is introduced to gather the necessary information on the \acrshort{vtk} implementation used. As most of the native implementation of the plugin is written in C++, we can either find a way to introduce introspection capabilities in C++ or use a language which both has a \acrshort{vtk} wrapper available and has such tools.

For the first option, some research has been carried out and the results are incomplete \cite{tyng1998nonintrusive} or introduce non-trivial overheads \cite{bayser2012rtti}, and in both cases would mean the introduction of further maintainability issues. The second option is not better either when it comes to new couplings, and we introduce a third language to the software as well as potential libraries necessary for communication.

As previous solutions already exist that offer some capabilities as we require for \acrshort{vtk} in Python \cite{dreuning_visual_2016}, we opt for an embedded design, even though it may not be the best performance-wise, it allows us to use established libraries with decent communities supporting them, whereas most C++ introspection extensions offer limited support.

From the Dreuning solution we adapt the \verb|ClassTree| implementation in order to strip it of its UI related code, as well as the \verb|PipelineObject| which we use as the introspective wrapper for the \acrshort{vtk} objects we instantiate to hold the getter and setter calls. We also expand this class to contain the description information of the \acrshort{vtk} objects that will be used by the UI Composer component to create UIs on the fly, that we will discuss in Section~\ref{sec:design-uicomposer}.

A further script has been produced to facilitate the calls from C++, exposing the required features for: (a) creating a (wrapped) \acrshort{vtk} object and return the C++ object's address; (b) getting the description of a \acrshort{vtk} object, i.e. its attributes and their types; (c) get the value of a \acrshort{vtk} object's attribute; (d) set the value of a \acrshort{vtk} object's attribute; and (e) delete the wrapper's information once the \acrshort{vtk} object gets deleted in the environment. 

%\begin{itemize}[leftmargin=1.5truecm]
%    \setlength{\itemindent}{-1truecm}
%    \item[] \verb|createVtkObject(objectName)| takes as input the name representation of the \acrshort{vtk} object class, and returns a (wrapped) \acrshort{vtk} object;
    
%\end{itemize}

To make the Python and the C++ components communicate we could either use shared memories to make the communication faster and keep them as separate components or directly embed the Python interpreter in the C++ component and use native calls to execute the python code. To limit resources usage and overhead, we chose the second option. 

In order to use this code from the C++ implementation, we need to embed the Python interpreter in the software. Fortunately, this is a use case covered in the Python/C API documentation\footnote{\url{https://docs.python.org/3.6/extending/embedding.html}}. While this solution already achieves a lot for our software, we handle a lot of objects and all the instantiation and de-instantiation of these objects requires a lot of verbose code. A few options are available to reduce the complexity of the code, in particular we consider the \verb|vtkPythonInterpreter| module from \acrshort{vtk} itself and the Boost::Python library that exposes a simplified version of the Python/C API for both embedding and extending \cite{abrahams2003building, schaling2011boost}.

Both present pros and cons, and in both cases impact the maintainability of the system. The \acrshort{vtk} module allows us to not couple our solution to further software, keeping all the external code encapsulated in \acrshort{vtk}. This is though a limited solution, as it exposes a very limited set of functionality of the Python/C API, based on previous uses of Python embedding in native \acrshort{vtk} software.

On the other hand, Boost is a more versatile library, which exposes a general purpose API for Python/C extending and embedding. Even though more powerful than the \acrshort{vtk} module, it still is not complete, and the Python/C API still needs to be used in particular situations. Furthermore, it presents some conflicts with how the Python/C API is intended to be used, e.g. the \verb|Py_Finalize()| should not be called when using Boost::Python. Adding the fact that this introduces a further coupling with external software, presents multiple challenges towards the maintainability of our solution.

Given these considerations, we opt for the integrated module of \acrshort{vtk} as to drive down unmaintainability factors.

\section{Managed Plugin}
\label{sec:design-managed-plugin}

\subsection{Toolbox}
\label{sec:design-toolbox}

\subsection{Composer}
\label{sec:design-uicomposer}