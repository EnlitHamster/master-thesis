\begin{appendices}

\chapter{Example VTK pipeline}
\label{apx:quadric-vtk}
	
\begin{cpp}[label=lst:quadricvtk,caption={Example of Quadric Contour in VTK.},aboveskip=20pt]
#include <vtkQuadric.h>
#include <vtkSampleFunction.h>
#include <vtkContourFilter.h>
#include <vtkOutlineFilter.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkImageData.h>
#include <vtkNew.h>
#include <vtkPolyData.h>

int main(int arc, char* argv)
{
	vtkNew<vtkQuadric> quadric;
	quadric->SetCoefficients(.5,1,.2,0,.1,0,0,.2,0,0);

	vtkNew<vtkSampleFunction> sample;
	sample->SetSampleDimensions(200,200,200);
	sample->SetImplicitFunction(quadric);

	vtkNew<vtkContourFilter> contours;
	contours->SetInputConnection(sample->GetOutputPort());
	contours->GenerateValues(5,0.0,1.2);

	vtkNew<vtkPolyDataMapper> contMapper;
	contMapper->SetInputConnection(contours->GetOutputPort());
	contMapper->SetScalarRange(0.0,1.2);

	vtkNew<vtkActor> contActor;
	contActor->SetMapper(contMapper);

	vtkNew<vtkOutlineFilter> outline;
	outline->SetInputConnection(sample->GetOutputPort());

	vtkNew<vtkPolyDataMapper> outlineMapper;
	outlineMapper->SetInputConnection(outline->GetOutputPort());

	vtkNew<vtkActor> outlineActor;
	outlineActor->SetMapper(outlineMapper);
	outlineActor->GetProperty()->SetColor(0,0,0);

	vtkNew<vtkRenderer> ren;
	vtkNew<vtkRenderWindow> renWin;
	renWin->AddRenderer(ren);

	vtkNew<vtkRenderWindowInteractor> iren;
	iren->SetRenderWindow(renWin);

	ren->AddActor(contActor);
	ren->AddActor(outlineActor);
	ren->SetBackground(1,1,1);

	renWin->Render();
	iren->Start();

	return EXIT_SUCCESS;
}
\end{cpp}
	
\chapter{VtkAdapterUtility code generator}
\label{apx:generate-register}
	
In order to generate at before build a register of all the adapters added to the plugin, a Python script has been created to automate this process. This will generate the necessary support class used within the plugin, i.e. \verb|VtkAdapterUtility|. This class is comprised of a fixed header file and an source file that changes depending on the installed adapters. The Listing~\ref{lst:generateheader} shows the code of such script. An example of generated source file is shown in Listing~\ref{lst:vtkadapterutilityex}

\begin{python}[label=lst:generateheader,caption={generate-header.py script},aboveskip=20pt]
import os

adapter_utility_h_name = "vtkAdapterUtility.h"
adapter_utility_cpp_name = "vtkAdapterUtility.cpp"
adapter_utility_class_name = "VtkAdapterUtility"
adapter_utility_getter_name = "GetAdapter"
adapter_utility_register_name = "s_adapters"
adapter_utility_register_type = "const std::unordered_map<LPCSTR, VtkAdapter*>"

adapter_utility_h = open(adapter_utility_h_name, "w")
adapter_utility_cpp = open(adapter_utility_cpp_name, "w")



### GENERATING HEADER FILE

adapter_utility_h.write("#pragma once\n")
adapter_utility_h.write("\n")
adapter_utility_h.write("/* This file has been automatically generated through the Python header generation utility\n")
adapter_utility_h.write(" * \n")
adapter_utility_h.write(" * This file contains the necessary information to allow the VtkToUnity plugin to know\n")
adapter_utility_h.write(" * that the adapters exist and it can call them. As such, this should be generated every\n")
adapter_utility_h.write(" * time the plugin is built to avoid losing any adapters in the compilation.\n")
adapter_utility_h.write(" */\n")
adapter_utility_h.write("\n")
adapter_utility_h.write("\n")

adapter_utility_h.write("// Utility includes\n")
adapter_utility_h.write("#include <unordered_map>\n")
adapter_utility_h.write("\n")
adapter_utility_h.write("#define NOMINMAX\n")
adapter_utility_h.write("#include <windows.h>\n")
adapter_utility_h.write("\n")
adapter_utility_h.write("#include \"../Singleton.h\"\n")
adapter_utility_h.write("#include \"../vtkAdapter.h\"\n")
adapter_utility_h.write("\n")


adapter_utility_h.write("\n")
adapter_utility_h.write("\n")
adapter_utility_h.write("// This class is used to register the adapters\n")
adapter_utility_h.write(f"class {adapter_utility_class_name}\n")
adapter_utility_h.write("{\n")

# Generating the class for the utility operations

adapter_utility_h.write("public:\n")

# begin public area

adapter_utility_h.write(f"\tstatic VtkAdapter* {adapter_utility_getter_name}(\n")
adapter_utility_h.write("\t\tLPCSTR vtkAdaptedObject);\n")
adapter_utility_h.write("\n")

# end public area

adapter_utility_h.write("private:\n")

# begin private area

adapter_utility_h.write("\t// Map with all the adapters registered in this folder\n")
adapter_utility_h.write(f"\tstatic {adapter_utility_register_type} {adapter_utility_register_name};\n")

# end private area

adapter_utility_h.write("};\n")



### GENERATING SOURCE FILE

adapter_utility_cpp.write("/* This file has been automatically generated through the Python header generation utility\n")
adapter_utility_cpp.write(" * \n")
adapter_utility_cpp.write(" * This file contains the necessary information to allow the VtkToUnity plugin to know\n")
adapter_utility_cpp.write(" * that the adapters exist and it can call them. As such, this should be generated every\n")
adapter_utility_cpp.write(" * time the plugin is built to avoid losing any adapters in the compilation.\n")
adapter_utility_cpp.write(" */\n")
adapter_utility_cpp.write("\n")
adapter_utility_cpp.write("\n")
adapter_utility_cpp.write(f"#include \"{adapter_utility_h_name}\"\n")
adapter_utility_cpp.write("\n")
adapter_utility_cpp.write("// Adapters' header files found in the folder (.h and .hpp)\n")

# Generating the includes of the adapters' header files

classes = []

for f in os.listdir("."):
    if f != adapter_utility_h_name and ( f.endswith(".h") or f.endswith(".hpp") ):
        adapter_utility_cpp.write(f"#include \"{f}\"\n")
        class_name = os.path.splitext(f)[0]
        classes.append(class_name[:1].upper() + class_name[1:])

adapter_utility_cpp.write("\n")
adapter_utility_cpp.write("\n")

# Creating the adapters' mapping

adapter_utility_cpp.write(f"{adapter_utility_register_type} {adapter_utility_class_name}::{adapter_utility_register_name} =");
adapter_utility_cpp.write("{\n")

# begin s_adapters init

for clss in classes:    
    adapter_utility_cpp.write(f"\t{{ Singleton<{clss}>::Instance()->GetAdaptingObject(), Singleton<{clss}>::Instance() }},\n")

# end s_adapters init

adapter_utility_cpp.write("};\n")

adapter_utility_cpp.write("\n")
adapter_utility_cpp.write("\n")

adapter_utility_cpp.write(f"VtkAdapter* {adapter_utility_class_name}::{adapter_utility_getter_name}(\n")
adapter_utility_cpp.write("\tLPCSTR vtkAdaptedObject)\n")
adapter_utility_cpp.write("{\n")

# begin GetAdapter

adapter_utility_cpp.write("\tauto itAdapter = s_adapters.find(vtkAdaptedObject);\n")
adapter_utility_cpp.write("\tif (itAdapter != s_adapters.end())\n")
adapter_utility_cpp.write("\t{\n")
adapter_utility_cpp.write("\t\treturn itAdapter->second;\n")
adapter_utility_cpp.write("\t}\n")
adapter_utility_cpp.write("\telse\n")
adapter_utility_cpp.write("\t{\n")
adapter_utility_cpp.write("\t\treturn NULL;\n")
adapter_utility_cpp.write("\t}\n")

# end GetAdapter

adapter_utility_cpp.write("}\n")
\end{python}
    
\begin{cpp}[label=lst:vtkadapterutilityex,caption={Example VtkAdapterUtility.cpp},aboveskip=20pt]
/* This file has been automatically generated through the Python header generation utility
 * 
 * This file contains the necessary information to allow the VtkToUnity plugin to know
 * that the adapters exist and it can call them. As such, this should be generated every
 * time the plugin is built to avoid losing any adapters in the compilation.
 */


#include "vtkAdapterUtility.h"

// Adapters' header files found in the folder (.h and .hpp)
#include "vtkConeSourceAdapter.h"


const std::unordered_map<LPCSTR, VtkAdapter*> VtkAdapterUtility::s_adapters ={
	{ Singleton<VtkConeSourceAdapter>::Instance()->GetAdaptingObject(), Singleton<VtkConeSourceAdapter>::Instance() },
};


VtkAdapter* VtkAdapterUtility::GetAdapter(
	LPCSTR vtkAdaptedObject)
{
	auto itAdapter = s_adapters.find(vtkAdaptedObject);
	if (itAdapter != s_adapters.end())
	{
		return itAdapter->second;
	}
	else
	{
		return NULL;
	}
}
\end{cpp}
    
\chapter{Python/C++ Performance tests}
\label{apx:streamtracer-performance-tests}

To evaluate the best approach towards introducing introspection into our project, we developed four tests that determine the performances of Python directly accessing \acrshort{vtk}, Python using introspection to access \acrshort{vtk}, C++ using the embedded Python interpreter to directly access \acrshort{vtk} and C++ using the embedded Python interpreter using introspection to access \acrshort{vtk}, the code for which is shown respectively in Listing~\ref{lst:py-native-vtk}, Listing~\ref{lst:py-intro-vtk}, Listing~\ref{lst:cpp-native-vtk} and Listing~\ref{lst:cpp-intro-vtk}. In both Python and C++ we use helper functions that time the execution of the functions we call. Their implementations are respectively shown in Listings~\ref{lst:py-timed-execution} and Listings~\ref{lst:cpp-timed-execution}.

\begin{python}[label=lst:py-native-vtk,caption={Native Python VTK benchmark script},aboveskip=20pt]
reader = timed_execution("reader_inst", vtkStructuredGridReader)
timed_execution("reader_setfile", reader.SetFileName, ("density.vtk",))
timed_execution("reader_update", reader.Update)

seeds = timed_execution("seeds_inst", vtkPointSource)
timed_execution("seeds_setradius", seeds.SetRadius, (3.0,))
timed_execution("seeds_setcenter_reader_getoutput_getcenter", seeds.SetCenter, (reader.GetOutput().GetCenter(),))
timed_execution("seeds_setnumberofpoints", seeds.SetNumberOfPoints, (100,))

streamer = timed_execution("streamer_inst", vtkStreamTracer)
timed_execution("streamer_setinputconn_reader_getoutputport", streamer.SetInputConnection, (reader.GetOutputPort(0),))
timed_execution("streamer_setsourceconn_seeds_getoutputport", streamer.SetSourceConnection, (seeds.GetOutputPort(0),))
timed_execution("streamer_setmaxpropagation", streamer.SetMaximumPropagation, (1000,))
timed_execution("streamer_setinitialintegstep", streamer.SetInitialIntegrationStep, (.1,))
timed_execution("streamer_setintegdirboth", streamer.SetIntegrationDirectionToBoth)

outline = timed_execution("outline_inst", vtkStructuredGridOutlineFilter)
timed_execution("outline_setinputconn_reader_getoutputport", outline.SetInputConnection, (reader.GetOutputPort(0),))
\end{python}

\begin{python}[label=lst:py-intro-vtk,caption={Introspective Python VTK benchmark script},aboveskip=20pt]
introspector = timed_execution("introspector_inst", Introspector)

reader = timed_execution("reader_inst", introspector.createVtkObject, ("vtkStructuredGridReader",))
timed_execution("reader_setfile", introspector.setVtkObjectAttribute, (reader, "FileName", "s", "density.vtk"))
timed_execution("reader_update", introspector.updateVtkObject, (reader,))

seeds = timed_execution("seeds_inst", introspector.createVtkObject, ("vtkPointSource",))
timed_execution("seeds_setradius", introspector.setVtkObjectAttribute, (seeds, "Radius", "f", 3.0))
center = timed_execution("reader_getoutputgetcenter", introspector.genericCall, (introspector.vtkInstanceCall(reader, "GetOutput", ()), "GetCenter", ()))
timed_execution("seeds_setcenter_reader_getoutput_getcenter", introspector.setVtkObjectAttribute, (seeds, "Center", "f3", introspector.outputFormat(center)))
timed_execution("seeds_setnumberofpoints", introspector.setVtkObjectAttribute, (seeds, "NumberOfPoints", "d", 100))

streamer = timed_execution("streamer_inst", introspector.createVtkObject, ("vtkStreamTracer",))
timed_execution("streamer_setinputconn_reader_getoutputport", introspector.vtkInstanceCall, (streamer, "SetInputConnection", (introspector.getVtkObjectOutputPort(reader),)))
timed_execution("streamer_setsourceconn_seeds_getoutputport", introspector.vtkInstanceCall, (streamer, "SetSourceConnection", (introspector.getVtkObjectOutputPort(seeds),)))
timed_execution("streamer_setmaxpropagation", introspector.setVtkObjectAttribute, (streamer, "MaximumPropagation", "d", 1000))
timed_execution("streamer_setinitialintegstep", introspector.setVtkObjectAttribute, (streamer, "InitialIntegrationStep", "f", .1))
timed_execution("streamer_setintegdirboth", introspector.vtkInstanceCall, (streamer, "SetIntegrationDirectionToBoth", ()))

outline = timed_execution("outline_inst", introspector.createVtkObject, ("vtkStructuredGridOutlineFilter",))
timed_execution("outline_setinputconn_reader_getoutputport", introspector.vtkInstanceCall, (outline, "SetInputConnection", (introspector.getVtkObjectOutputPort(reader),)))
\end{python}

\begin{python}[label=lst:py-timed-execution,caption={timed\_execution Python function},aboveskip=20pt]
time_execution_data = {}
def timed_execution(name, func, args = ()):
	t_start = perf_counter()
	r = func(*args)
	time_execution_data[name] = perf_counter() - t_start
	return r
\end{python}

\end{appendices}